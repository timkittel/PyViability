<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyviability.libviability &#8212; pyviability 0.2.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>pyviability 0.2.0 documentation</span></a></h1>
        <h2 class="heading"><span>pyviability.libviability</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for pyviability.libviability</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Basic module that contains most of the relevant routines.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">generators</span>

<span class="kn">from</span> <span class="nn">.tsm_style</span> <span class="k">import</span> <span class="n">tsm_colors</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">periodic_kdtree</span> <span class="k">as</span> <span class="n">periodkdt</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>

<span class="kn">import</span> <span class="nn">scipy.integrate</span> <span class="k">as</span> <span class="nn">integ</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span> <span class="k">as</span> <span class="nn">spat</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">warnings</span> <span class="k">as</span> <span class="nn">warn</span>

<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">functools</span> <span class="k">as</span> <span class="nn">ft</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>

<span class="c1">#################################################################</span>
<span class="c1"># Disclaimer:</span>
<span class="c1"># Most of the Code is written in functions so numba speed-up can</span>
<span class="c1"># be used easily. Everything will be wrapped in classes as soon</span>
<span class="c1"># as numba.jitclass has stabilized.</span>
<span class="c1">#################################################################</span>

<span class="c1">#################################################################</span>
<span class="c1"># Some doc strings are as comments, because the functions should</span>
<span class="c1"># not appear in the actual documentation. Usually, that is</span>
<span class="c1"># because they are still experimental.</span>
<span class="c1">#################################################################</span>


<span class="c1"># flush the output of print by default</span>
<span class="nb">print</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># raise the odeing warning as an error because it indicates that we are at a</span>
<span class="c1"># fixed point (or the grid is not fine enough)</span>
<span class="n">warn</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">integ</span><span class="o">.</span><span class="n">odepack</span><span class="o">.</span><span class="n">ODEintWarning</span><span class="p">)</span>

<span class="c1"># these are automatically set during grid generation but need to be manually set</span>
<span class="c1"># when using own grid</span>
<span class="n">BOUNDS_EPSILON</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># should be set during grid Generation</span>
<span class="n">STEPSIZE</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">INDEX_TYPE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
<span class="n">INDEX_TYPE_NB</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">int64</span>

<span class="c1"># some constants so the calculation does end</span>
<span class="n">MAX_ITERATION_EDDIES</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">DEBUGGING</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">VERBOSITY</span> <span class="o">=</span> <span class="mi">0</span>


<span class="c1"># the stuff for remembering the status</span>
<span class="n">STATUS</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">STATUS_PREFIX</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">TOPOLOGY_STEP_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;GENERAL&quot;</span><span class="p">,</span> <span class="s2">&quot;SHELTER&quot;</span><span class="p">,</span> <span class="s2">&quot;GLADE&quot;</span><span class="p">,</span> <span class="s2">&quot;REMUP&quot;</span><span class="p">,</span> <span class="s2">&quot;MANAGEABLE&quot;</span><span class="p">,</span> <span class="s2">&quot;REMDOWN&quot;</span><span class="p">,</span> <span class="s2">&quot;REST&quot;</span><span class="p">,</span> <span class="s2">&quot;GENERAL&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>  <span class="c1"># the empty one is so that can be given, too</span>
<span class="n">STATUS_TOPOLOGY</span> <span class="o">=</span> <span class="s2">&quot;TOPOLOGY&quot;</span>
<span class="n">STATUS_INFIX</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
<span class="n">STATUS_PREPARATION</span> <span class="o">=</span> <span class="s2">&quot;PREPARATION&quot;</span>
<span class="n">STATUS_COMPUTATION</span> <span class="o">=</span> <span class="s2">&quot;COMPUTATION&quot;</span>
<span class="n">STATUS_POSTPROCESSING</span> <span class="o">=</span> <span class="s2">&quot;POSTPROCESSING&quot;</span>
<span class="n">STATUS_DONE</span> <span class="o">=</span> <span class="s2">&quot;DONE&quot;</span>
<span class="n">STATUS_EDDIES_DARK</span> <span class="o">=</span> <span class="s2">&quot;EDDIES_DARK&quot;</span>
<span class="n">STATUS_EDDIES_SUNNY</span> <span class="o">=</span> <span class="s2">&quot;EDDIES_SUNNY&quot;</span>

<span class="c1"># verbose printing stuff</span>
<span class="n">PRINT_PREFIX</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">PRINT_INFIX</span> <span class="o">=</span> <span class="s2">&quot; :&quot;</span>
<span class="n">PRINT_INFIX_BEHIND</span> <span class="o">=</span> <span class="s2">&quot;( &quot;</span>
<span class="n">PRINT_POSTFIX_BEHIND</span> <span class="o">=</span> <span class="s2">&quot; )&quot;</span>

<span class="c1"># The ones below are just used by the default pre-calculation hook and the</span>
<span class="c1"># default state evaluation. They are just here so they are not used for</span>
<span class="c1"># something else.</span>
<span class="n">KDTREE</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">STATES</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">BOUNDS</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">BASIS_VECTORS</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">BASIS_VECTORS_INV</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">OUT_OF_BOUNDS</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">COORDINATES</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">ALL_NEIGHBORS_DISTANCE</span> <span class="o">=</span> <span class="kc">None</span>


<span class="c1"># ---- stuff for remembering the paths ----</span>
<span class="n">PATHS</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">PATHS_LAKE</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">PATHS_INDEX_TYPE</span> <span class="o">=</span> <span class="n">INDEX_TYPE</span>
<span class="n">PATHS_INDEX_DEFAULT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">PATHS_INDEX_TYPE</span><span class="p">)</span><span class="o">.</span><span class="n">min</span>
<span class="n">PATHS_MANAGEMENT_TYPE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span>
<span class="n">PATHS_MANAGEMENT_DEFAULT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">PATHS_MANAGEMENT_TYPE</span><span class="p">)</span><span class="o">.</span><span class="n">min</span>

<span class="c1"># ---- states ----</span>
<span class="c1"># encode the different states as integers, so arrays of integers can be used</span>
<span class="c1"># later in numpy arrays (which are very fast on integers)</span>
<span class="c1"># None state should never be used as it is used to indicate out of bounds</span>
<span class="n">REGIONS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;UNSET&quot;</span><span class="p">,</span> <span class="s2">&quot;SHELTER&quot;</span><span class="p">,</span> <span class="s2">&quot;GLADE&quot;</span><span class="p">,</span> <span class="s2">&quot;LAKE&quot;</span><span class="p">,</span> <span class="s2">&quot;SUNNY_UP&quot;</span><span class="p">,</span> <span class="s2">&quot;DARK_UP&quot;</span><span class="p">,</span> <span class="s2">&quot;BACKWATERS&quot;</span><span class="p">,</span> <span class="s2">&quot;SUNNY_DOWN&quot;</span><span class="p">,</span> <span class="s2">&quot;DARK_DOWN&quot;</span><span class="p">,</span> <span class="s2">&quot;SUNNY_EDDIES&quot;</span><span class="p">,</span> <span class="s2">&quot;DARK_EDDIES&quot;</span><span class="p">,</span> <span class="s2">&quot;SUNNY_ABYSS&quot;</span><span class="p">,</span> <span class="s2">&quot;DARK_ABYSS&quot;</span><span class="p">,</span> <span class="s2">&quot;TRENCH&quot;</span><span class="p">]</span>
<span class="n">UNSET</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">SHELTER</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">GLADE</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">LAKE</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">SUNNY_UP</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">DARK_UP</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">BACKWATERS</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">SUNNY_DOWN</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">DARK_DOWN</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">SUNNY_EDDIES</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">DARK_EDDIES</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">SUNNY_ABYSS</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">DARK_ABYSS</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">TRENCH</span> <span class="o">=</span> <span class="mi">13</span>

<span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">REGIONS</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">globals</span><span class="p">())</span>


<span class="n">OTHER_STATE</span> <span class="o">=</span> <span class="mi">14</span>  <span class="c1"># used for computation reasons only</span>
<span class="n">OUT_OF_BOUNDS_STATE</span> <span class="o">=</span> <span class="mi">15</span>


<span class="c1"># ---- Colors ----</span>
<span class="c1"># identify the states with the corresponding colors in order to be consistent</span>
<span class="c1"># with the color definitions from the original paper</span>
<span class="n">COLORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">UNSET</span><span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
        <span class="o">-</span><span class="n">SHELTER</span><span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
        <span class="o">-</span><span class="n">GLADE</span><span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
        <span class="n">SHELTER</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cShelter&quot;</span><span class="p">],</span>
        <span class="n">GLADE</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cGlade&quot;</span><span class="p">],</span>
        <span class="n">LAKE</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cLake&quot;</span><span class="p">],</span>
        <span class="n">SUNNY_UP</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cSunnyUp&quot;</span><span class="p">],</span>
        <span class="n">DARK_UP</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cDarkUp&quot;</span><span class="p">],</span>
        <span class="n">BACKWATERS</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cBackwaters&quot;</span><span class="p">],</span>
        <span class="n">SUNNY_DOWN</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cSunnyDown&quot;</span><span class="p">],</span>
        <span class="n">DARK_DOWN</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cDarkDown&quot;</span><span class="p">],</span>
        <span class="n">SUNNY_EDDIES</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cSunnyEddie&quot;</span><span class="p">],</span>
        <span class="n">DARK_EDDIES</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cDarkEddie&quot;</span><span class="p">],</span>
        <span class="n">SUNNY_ABYSS</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cSunnyAbyss&quot;</span><span class="p">],</span>
        <span class="n">DARK_ABYSS</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cDarkAbyss&quot;</span><span class="p">],</span>
        <span class="n">TRENCH</span><span class="p">:</span> <span class="n">tsm_colors</span><span class="p">[</span><span class="s2">&quot;cTrench&quot;</span><span class="p">],</span>
        <span class="p">}</span>


<div class="viewcode-block" id="printv"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.printv">[docs]</a><span class="k">def</span> <span class="nf">printv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">date_behind</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print the output depending on the given verbosity.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;flush&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;flush&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&lt;=</span> <span class="n">VERBOSITY</span><span class="p">:</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>
        
        <span class="n">print_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">date_behind</span><span class="p">:</span>
            <span class="n">print_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PRINT_INFIX_BEHIND</span> <span class="o">+</span> <span class="n">date</span> <span class="o">+</span> <span class="n">PRINT_POSTFIX_BEHIND</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">print_args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PRINT_PREFIX</span> <span class="o">+</span> <span class="n">date</span> <span class="o">+</span> <span class="n">PRINT_INFIX</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">print_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">printd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Print the output depending on the global variable `DEDBUGGING`.</span>
    <span class="k">if</span> <span class="s2">&quot;flush&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;flush&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">DEBUGGING</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Delta_series</span><span class="p">(</span><span class="n">Delta_0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
    <span class="c1"># create the detla series for a simplex-based grid</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Delta_0</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">p_series</span><span class="p">(</span><span class="n">Delta_0</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
    <span class="c1"># returns the p vectors as an array p[i, j] where j enumerates the \</span>
    <span class="c1"># vector (and thus dimension) and i the component</span>
    <span class="n">p_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">Delta_n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Delta_series</span><span class="p">(</span><span class="n">Delta_0</span><span class="p">,</span> <span class="n">dim</span><span class="p">)):</span>
        <span class="n">p_all</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p_all</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">p_all</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">Delta_n</span>
    <span class="k">return</span> <span class="n">p_all</span>


<div class="viewcode-block" id="generate_grid"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.generate_grid">[docs]</a><span class="k">def</span> <span class="nf">generate_grid</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">grid_type</span> <span class="o">=</span> <span class="s2">&quot;orthogonal&quot;</span><span class="p">,</span> <span class="n">periodicity</span><span class="o">=</span><span class="p">[],</span> <span class="n">verbosity</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a grid, that is already normalized to [0, 1]^dimension.</span>

<span class="sd">    **Note:** This function also sets globally MAX_NEIGHBOR_DISTANCE, BOUNDS_EPSILON, STEPSIZE, ALL_NEIGHBORS_DISTANCE.</span>
<span class="sd">    So if you don&#39;t use this function, you need to set it yourself by hand.</span>
<span class="sd">    Later, this will be circumvented by using proper OO-programming.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    boundaries : array-like</span>
<span class="sd">        shape (dim, 2), give the boundaries (min and max) for each dimension of the mode system</span>
<span class="sd">    n0 : non-negative int</span>
<span class="sd">        total number of points that the grid should have</span>
<span class="sd">    grid_type : str, default: &quot;orthogonal&quot;</span>
<span class="sd">        specify the grid_type to be created. experimental, only use if your know what you do</span>
<span class="sd">    periodicity : array-like, default: []</span>
<span class="sd">        specify if there is an peridicity given (to avoid overlapping points)</span>
<span class="sd">    verbosity : bool, default: True</span>
<span class="sd">        specify the verbosity</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        (grid, scaling_vectors, offset, x_step) with</span>
<span class="sd">            `grid`: the actual rescaled grid</span>

<span class="sd">            `scaling_vectors`, `offset` : parameters to scale the grid back to the original size</span>

<span class="sd">            `x_step` : stepsize of the grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">MAX_NEIGHBOR_DISTANCE</span><span class="p">,</span> <span class="n">BOUNDS_EPSILON</span><span class="p">,</span> <span class="n">STEPSIZE</span><span class="p">,</span> <span class="n">ALL_NEIGHBORS_DISTANCE</span>
    <span class="c1"># These are set globally afterwards.</span>

    <span class="k">assert</span> <span class="n">grid_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;simplex-based&quot;</span><span class="p">,</span> <span class="s2">&quot;orthogonal&quot;</span><span class="p">],</span> <span class="s2">&quot;unkown grid type &#39;</span><span class="si">{!s}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid_type</span><span class="p">)</span>

    <span class="n">boundaries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span>
    <span class="n">periodicity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">periodicity</span><span class="p">)</span>

    <span class="n">dim</span> <span class="o">=</span> <span class="n">boundaries</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">scaling_factor</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundaries</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">periodicity</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">periodicity</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">dim</span><span class="p">,))</span>

    <span class="k">assert</span> <span class="n">periodicity</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">dim</span><span class="p">,),</span> <span class="s2">&quot;given boundaries do not match periodicity input&quot;</span>

    <span class="n">periodicity_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">periodicity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1">#############################</span>
    <span class="c1"># generate the basic grid</span>
    <span class="c1">#############################</span>
    <span class="n">grid_prep_aperiodic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n0</span><span class="p">)</span>
    <span class="n">grid_prep_periodic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n0</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># the last point is not set as it would be the same as the first one in</span>
    <span class="c1"># a periodic grid</span>
    <span class="n">grid_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">grid_prep_periodic</span> <span class="k">if</span> <span class="n">periodicity_bool</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">else</span> <span class="n">grid_prep_aperiodic</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>

    <span class="c1"># create the grid</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grid_args</span><span class="p">))</span>

    <span class="c1"># move the axis with the dimenion to the back</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># flattening the array</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

    <span class="n">x_step</span> <span class="o">=</span> <span class="n">grid_prep_periodic</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">grid_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;orthogonal&quot;</span><span class="p">]:</span>

        <span class="n">scaling_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">scaling_factor</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">x_step</span> <span class="o">==</span> <span class="n">grid_prep_aperiodic</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;bug?&quot;</span>
        <span class="n">MAX_NEIGHBOR_DISTANCE</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">x_step</span>
        <span class="n">BOUNDS_EPSILON</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">x_step</span>
        <span class="n">ALL_NEIGHBORS_DISTANCE</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_step</span> <span class="o">+</span> <span class="n">BOUNDS_EPSILON</span>
        <span class="c1"># print(&quot;x_step&quot;, x_step)</span>
        <span class="c1"># print(&quot;ALL_NEIGHBORS_DISTANCE&quot;, ALL_NEIGHBORS_DISTANCE)</span>
        <span class="c1"># assert False</span>
        <span class="c1"># ALL_NEIGHBORS_DISTANCE = np.sqrt(dim) * x_step + BOUNDS_EPSILON</span>
        <span class="c1"># STEPSIZE = ALL_NEIGHBORS_DISTANCE</span>
        <span class="c1"># STEPSIZE = 1.5 * x_step</span>
        <span class="c1"># STEPSIZE = 2.5 * x_step</span>
        <span class="n">STEPSIZE</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">x_step</span>

    <span class="k">elif</span> <span class="n">grid_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;simplex-based&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">periodicity_bool</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="c1"># the periodic binary tree can handle orthogonal periodicity only</span>
            <span class="c1"># because the first basis vector for the simplex based grid is</span>
            <span class="c1"># parallel to the x-axis, orthogonality in the first dimension is</span>
            <span class="c1"># okai and the if statement above tests only periodicity_bool[1:]</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The generation of the simplex-based grid is not yet compatible with periodic state spaces (except in the first dimension).&quot;</span><span class="p">)</span>

        <span class="n">basis_vectors</span> <span class="o">=</span> <span class="n">p_series</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">scaling_vectors</span> <span class="o">=</span> <span class="n">basis_vectors</span> <span class="o">/</span> <span class="n">scaling_factor</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">basis_vectors</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)])</span>

        <span class="c1"># when recursively going through, then add the direct neighbors only</span>
        <span class="n">MAX_NEIGHBOR_DISTANCE</span> <span class="o">=</span> <span class="mf">1.01</span> <span class="o">*</span> <span class="n">x_step</span>
        <span class="c1"># x_step = Delta_0 # Delta_0 is side length of the simplices</span>
        <span class="n">BOUNDS_EPSILON</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">x_step</span>
        <span class="n">STEPSIZE</span> <span class="o">=</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">x_step</span>  <span class="c1"># seems to be correct</span>
        <span class="n">ALL_NEIGHBORS_DISTANCE</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">basis_vectors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">x_step</span> <span class="o">+</span> <span class="n">BOUNDS_EPSILON</span>

    <span class="k">if</span> <span class="n">verbosity</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;created </span><span class="si">{:d}</span><span class="s2"> points&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">scaling_vectors</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">x_step</span></div>


<span class="k">def</span> <span class="nf">_generate_viability_single_point</span><span class="p">(</span><span class="n">evolutions</span><span class="p">,</span> <span class="n">state_evaluation</span><span class="p">,</span> <span class="n">use_numba</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nb_nopython</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">use_numba</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;numba usage doesn&#39;t really make sense here, because KDTREE cannot be numba jitted&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">_viability_single_point</span><span class="p">(</span><span class="n">coordinate_index</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span>
                                    <span class="n">stop_states</span><span class="p">,</span> <span class="n">succesful_state</span><span class="p">,</span> <span class="n">else_state</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Calculate whether a coordinate with value &#39;stop_value&#39; can be reached from &#39;coordinates[coordinate_index]&#39;.&quot;&quot;&quot;</span>

            <span class="n">start</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">coordinate_index</span><span class="p">]</span>
            <span class="n">start_state</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">coordinate_index</span><span class="p">]</span>

            <span class="k">global</span> <span class="n">DEBUGGING</span><span class="p">,</span> <span class="n">PATHS</span>
            <span class="c1"># Keep the below statements as they are rather useful for the debugging.</span>
            <span class="c1"># Will be removed for the 1.0 release (one day ^^).</span>
            <span class="c1"># DEBUGGING = True</span>
            <span class="c1"># DEBUGGING = DEBUGGING and STATUS == &quot;TOPOLOGY MANAGEABLE COMPUTATION&quot;</span>
            <span class="c1"># DEBUGGING = DEBUGGING and (start_state == 1)</span>
            <span class="c1"># DEBUGGING = (coordinate_index == (10 * 80 - 64,))</span>
            <span class="c1"># DEBUGGING = DEBUGGING and la.norm(start - np.array([0.0777,  0.947,  1.])) &lt; 0.05</span>
            <span class="c1"># DEBUGGING = DEBUGGING and la.norm(start - np.array([0.008, 0.747])) &lt; 0.001</span>
            <span class="c1"># DEBUGGING = DEBUGGING and start[0] &lt; 0.01</span>
            <span class="c1"># DEBUGGING = DEBUGGING and start_state == 1</span>
            <span class="c1"># DEBUGGING = DEBUGGING or la.norm(start - np.array([0.1, 0.606])) &lt; 0.02</span>
            <span class="c1"># DEBUGGING = True</span>
            <span class="c1"># print(&quot;DEBUGGING&quot;, DEBUGGING)</span>

            <span class="c1"># if DEBUGGING:</span>
                <span class="c1"># print()</span>

            <span class="k">for</span> <span class="n">evol_num</span><span class="p">,</span> <span class="n">evol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">evolutions</span><span class="p">):</span>
                <span class="n">traj</span> <span class="o">=</span> <span class="n">evol</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">STEPSIZE</span><span class="p">)</span>

                <span class="n">final_index</span><span class="p">,</span> <span class="n">final_state</span> <span class="o">=</span> <span class="n">state_evaluation</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">final_state</span> <span class="ow">in</span> <span class="n">stop_states</span><span class="p">:</span>  <span class="c1"># and constraint(point) and final_distance &lt; MAX_FINAL_DISTANCE:</span>

                    <span class="k">if</span> <span class="n">PATHS</span><span class="p">:</span>
                        <span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;reached point&quot;</span><span class="p">][</span><span class="n">coordinate_index</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;next point index&quot;</span><span class="p">][</span><span class="n">coordinate_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_index</span>
                        <span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;choice&quot;</span><span class="p">][</span><span class="n">coordinate_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">evol_num</span>

                    <span class="k">if</span> <span class="n">DEBUGGING</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;</span><span class="si">%i</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="n">evol_num</span><span class="p">,</span> <span class="n">coordinate_index</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start_state</span><span class="p">,</span> <span class="s2">&quot;--&gt;&quot;</span><span class="p">,</span> <span class="n">final_state</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">succesful_state</span>

                <span class="c1"># run the other evolutions to check whether they can reach a point with &#39;stop_state&#39;</span>
                <span class="k">if</span> <span class="n">DEBUGGING</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2">:&quot;</span><span class="o">%</span><span class="n">evol_num</span><span class="p">,</span> <span class="n">coordinate_index</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start_state</span><span class="p">,</span> <span class="s2">&quot;## break&quot;</span><span class="p">)</span>

            <span class="c1"># didn&#39;t find an option leading to a point with &#39;stop_state&#39;</span>
            <span class="k">if</span> <span class="n">DEBUGGING</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;all:&quot;</span><span class="p">,</span> <span class="n">coordinate_index</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start_state</span><span class="p">,</span> <span class="s2">&quot;--&gt;&quot;</span><span class="p">,</span> <span class="n">else_state</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">else_state</span>
    <span class="k">return</span> <span class="n">_viability_single_point</span>


<span class="k">def</span> <span class="nf">_state_evaluation_kdtree_line</span><span class="p">(</span><span class="n">traj</span><span class="p">):</span>
    <span class="c1"># deprecated (for now ^^)</span>
    <span class="n">start_point</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">final_point</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># print(&quot;start_point&quot;, start_point)</span>
    <span class="c1"># print(&quot;final_point&quot;, final_point)</span>

    <span class="k">if</span> <span class="n">OUT_OF_BOUNDS</span><span class="p">:</span>
        <span class="c1"># check whether out-of-bounds</span>
        <span class="n">projected_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">BASIS_VECTORS_INV</span><span class="p">,</span> <span class="n">final_point</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="n">BOUNDS</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">projected_values</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="n">BOUNDS</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">projected_values</span> <span class="p">):</span>  <span class="c1"># is the point out-of-bounds?</span>
            <span class="k">if</span> <span class="n">DEBUGGING</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;out-of-bounds&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">OUT_OF_BOUNDS_STATE</span>

    <span class="c1"># assert False, &quot;out of bounds doesn&#39;t seem to work?&quot;</span>

    <span class="c1"># if not out-of-bounds, determine where it went to</span>

    <span class="c1"># print(&quot;ALL_NEIGHBORS_DISTANCE&quot;, ALL_NEIGHBORS_DISTANCE)</span>
    <span class="c1"># print(&quot;start_point&quot;, start_point)</span>
    <span class="n">neighbor_indices</span> <span class="o">=</span> <span class="n">KDTREE</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">start_point</span><span class="p">,</span> <span class="n">ALL_NEIGHBORS_DISTANCE</span><span class="p">)</span>
    <span class="c1"># print(&quot;neighbor_indices&quot;, neighbor_indices)</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">KDTREE</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">neighbor_indices</span><span class="p">]</span>
    <span class="c1"># print(&quot;neighbors&quot;, neighbors)</span>
    <span class="c1"># print(&quot;KDTREE.data[2]&quot;, KDTREE.data[2])</span>
    <span class="c1"># print(&quot;diff&quot;, neighbors - KDTREE.data[2])</span>
    <span class="c1"># print(&quot;norm(diff)&quot;, la.norm(neighbors - KDTREE.data[2], axis=-1))</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">KDTREE</span><span class="p">,</span> <span class="s2">&quot;bounds&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">DEBUGGING</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bounds&quot;</span><span class="p">,</span> <span class="n">KDTREE</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">bool_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">KDTREE</span><span class="o">.</span><span class="n">bounds</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">newbounds</span> <span class="o">=</span> <span class="n">KDTREE</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">bool_bounds</span><span class="p">]</span>
        <span class="n">_start_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">start_point</span><span class="p">)</span>
        <span class="n">_start_point</span><span class="p">[</span><span class="n">bool_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_point</span><span class="p">[</span><span class="n">bool_bounds</span><span class="p">]</span> <span class="o">%</span> <span class="n">newbounds</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_start_point</span> <span class="o">=</span> <span class="n">start_point</span>
    <span class="n">_start_point_local_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">_start_point</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">_start_point_global_index</span> <span class="o">=</span> <span class="n">neighbor_indices</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">_start_point_local_index</span><span class="p">)</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">_start_point_local_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">_start_point_local_index</span>

    <span class="k">if</span> <span class="n">DEBUGGING</span><span class="p">:</span>
        <span class="c1"># print(&quot;start_point&quot;, start_point)</span>
        <span class="c1"># print(neighbors.shape)</span>
        <span class="c1"># print(&quot;neighbors&quot;)</span>
        <span class="c1"># print(neighbors)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">start_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                 <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">_start_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_start_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                 <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">neighbors</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                 <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">final_point</span> <span class="o">-</span> <span class="n">start_point</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">closest_index</span> <span class="o">=</span> <span class="n">_start_point_global_index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># print(&quot;neighbors&quot;, neighbors)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">neighbors</span> <span class="o">-</span> <span class="n">start_point</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># take care of the periodic boundaries</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">KDTREE</span><span class="p">,</span> <span class="s2">&quot;bounds&quot;</span><span class="p">):</span>
            <span class="n">newbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">KDTREE</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
            <span class="c1"># newbounds = np.array(KDTREE.bounds)</span>
            <span class="c1"># newbounds[newbounds &lt;= 0] = np.infty</span>
            <span class="n">shiftbounds</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">newbounds</span><span class="p">)</span>
            <span class="n">warn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;using cheap fix for periodic boundary here&quot;</span><span class="p">)</span>
            <span class="c1"># if DEBUGGING:</span>
                <span class="c1"># print(&quot;a&quot;, a)</span>
                <span class="c1"># print(&quot;b&quot;, b)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">shiftbounds</span><span class="p">)</span> <span class="o">%</span> <span class="n">newbounds</span> <span class="o">-</span> <span class="n">shiftbounds</span>
            <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">shiftbounds</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span> <span class="o">%</span> <span class="n">newbounds</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">shiftbounds</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># if DEBUGGING:</span>
            <span class="c1"># print(&quot;a&quot;, a)</span>
            <span class="c1"># print(&quot;b&quot;, b)</span>

        <span class="n">_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)])</span>

        <span class="n">distances_to_line_squared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> \
            <span class="n">_p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">_p</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  <span class="c1"># the signum of _p is used to find the correct side</span>

        <span class="n">_n_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances_to_line_squared</span><span class="p">)</span>

        <span class="n">closest_index</span> <span class="o">=</span> <span class="n">neighbor_indices</span><span class="p">[</span><span class="n">_n_index</span><span class="p">]</span>

    <span class="n">final_state</span> <span class="o">=</span> <span class="n">STATES</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">DEBUGGING</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;evaluation:&quot;</span><span class="p">,</span> <span class="n">start_point</span><span class="p">,</span> <span class="s2">&quot;via&quot;</span><span class="p">,</span> <span class="n">final_point</span><span class="p">,</span> <span class="s2">&quot;to&quot;</span><span class="p">,</span> <span class="n">KDTREE</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">closest_index</span><span class="p">],</span> <span class="s2">&quot;with state&quot;</span><span class="p">,</span> <span class="n">final_state</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">closest_index</span><span class="p">,</span> <span class="n">final_state</span>


<div class="viewcode-block" id="state_evaluation_kdtree"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.state_evaluation_kdtree">[docs]</a><span class="k">def</span> <span class="nf">state_evaluation_kdtree</span><span class="p">(</span><span class="n">traj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the closest point to the end of the trajectory in the grid using KDTREE.</span>

<span class="sd">    **Note:** Used internally during the viability computations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># global DEBUGGING</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">OUT_OF_BOUNDS</span><span class="p">:</span>
        <span class="n">projected_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">projected_values</span> <span class="o">+=</span> <span class="n">BASIS_VECTORS_INV</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">out</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">BOUNDS</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">projected_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">BOUNDS</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">projected_values</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="c1"># DEBUGGING = False</span>
            <span class="c1"># if DEBUGGING:</span>
                <span class="c1"># print(&quot;out-of-bounds&quot;)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">OUT_OF_BOUNDS_STATE</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">tree_index</span> <span class="o">=</span> <span class="n">KDTREE</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># DEBUGGING = DEBUGGING and (STATES[tree_index] in [-1, 1, -2, 2])</span>
    <span class="c1"># if DEBUGGING:</span>
        <span class="c1"># print(&quot;evaluation:&quot;, traj[0], &quot;via&quot;, traj[1], &quot;to&quot;, KDTREE.data[tree_index], &quot;with state&quot;, STATES[tree_index])</span>

    <span class="k">return</span> <span class="n">tree_index</span><span class="p">,</span> <span class="n">STATES</span><span class="p">[</span><span class="n">tree_index</span><span class="p">]</span></div>


<span class="c1"># def state_evaluation_kdtree(traj):</span>
<span class="c1">#     point = traj[-1]</span>
<span class="c1">#     if OUT_OF_BOUNDS:</span>
<span class="c1">#         projected_values = np.tensordot(BASIS_VECTORS_INV, point, axes=[(1,), (0,)])</span>
<span class="c1">#         if np.any( BOUNDS[:, 0] &gt; projected_values) or np.any( BOUNDS[:, 1] &lt; projected_values ):  # is the point out-of-bounds?</span>
<span class="c1">#             if DEBUGGING:</span>
<span class="c1">#                 print(&quot;out-of-bounds&quot;)</span>
<span class="c1">#             return OUT_OF_BOUNDS_STATE</span>
<span class="c1">#     _, tree_index = KDTREE.query(point, 1)</span>
<span class="c1">#     return tree_index, STATES[tree_index]</span>


<div class="viewcode-block" id="pre_calculation_hook_kdtree"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.pre_calculation_hook_kdtree">[docs]</a><span class="k">def</span> <span class="nf">pre_calculation_hook_kdtree</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span>
                                <span class="n">is_sunny</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">periodicity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">grid_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">out_of_bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Do all prepratory stuff for a viability computation.</span>

<span class="sd">    **Note:** Usually used internally only.</span>

<span class="sd">    This function creates the KDTREE, makes a variety of variables globally accessible.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">KDTREE</span><span class="p">,</span> <span class="n">STATES</span><span class="p">,</span> <span class="n">BASIS_VECTORS</span><span class="p">,</span> <span class="n">BASIS_VECTORS_INV</span><span class="p">,</span> <span class="n">BOUNDS</span><span class="p">,</span> <span class="n">OUT_OF_BOUNDS</span>
    <span class="n">STATES</span> <span class="o">=</span> <span class="n">states</span>

    <span class="n">dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">periodicity_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">periodicity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">printv</span><span class="p">(</span><span class="s2">&quot;creating k-d tree ...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># check, if there are periodic boundaries and if so, use different tree form</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">periodicity_bool</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">dim</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">periodicity_bool</span><span class="p">),</span> <span class="s2">&quot;Given boundaries don&#39;t match with &quot;</span> \
                                                    <span class="s2">&quot;dimensions of coordinates. &quot;</span> \
                                                    <span class="s2">&quot;Write &#39;-1&#39; if boundary is not periodic!&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">grid_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;orthogonal&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">((</span><span class="n">grid_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;simplex-based&quot;</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">periodicity_bool</span><span class="p">[</span><span class="mi">1</span><span class="p">:])),</span>\
            <span class="s2">&quot;does PeriodicCKDTREE support the periodicity for your grid?&quot;</span>
        <span class="n">KDTREE</span> <span class="o">=</span> <span class="n">periodkdt</span><span class="o">.</span><span class="n">PeriodicCKDTree</span><span class="p">(</span><span class="n">periodicity</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">KDTREE</span> <span class="o">=</span> <span class="n">spat</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
    <span class="n">printv</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">,</span> <span class="n">date_behind</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">OUT_OF_BOUNDS</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">out_of_bounds</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">OUT_OF_BOUNDS</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">out_of_bounds</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]]</span> <span class="o">*</span> <span class="n">dim</span>
        <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out_of_bounds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out_of_bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">dim</span><span class="p">,):</span>
            <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">out_of_bounds</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">out_of_bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">BOUNDS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">grid_type</span> <span class="o">==</span> <span class="s2">&quot;orthogonal&quot;</span><span class="p">:</span>
            <span class="n">basis_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">grid_type</span> <span class="o">==</span> <span class="s2">&quot;simplex-based&quot;</span><span class="p">:</span>
            <span class="n">basis_vectors</span> <span class="o">=</span> <span class="n">p_series</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

        <span class="n">BASIS_VECTORS</span> <span class="o">=</span> <span class="n">basis_vectors</span>
        <span class="n">BASIS_VECTORS_INV</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">BASIS_VECTORS</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">periodicity_bool</span><span class="p">[</span><span class="n">d</span><span class="p">]:</span>
                <span class="n">BOUNDS</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="c1"># this basically means, because of periodicity, the trajectories</span>
                <span class="c1"># cannot run out-of-bounds</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># project the values on the basis vector with a scalar product</span>
                <span class="c1"># for that reason, basis vectors need to be normalized</span>
                <span class="c1"># projected_values = np.tensordot(coordinates, basis_vectors[:,d], axes=[(1,), (0,)])</span>

                <span class="c1"># actually the idea above is correct and this is simply the result</span>
                <span class="c1"># combined with the checking whether out-of-bounds should be</span>
                <span class="c1"># applied</span>
                <span class="n">BOUNDS</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">out_of_bounds</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="n">BOUNDS_EPSILON</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">BOUNDS_EPSILON</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">))</span>

                <span class="c1"># BOUNDS[d,:] = np.min(projected_values) - BOUNDS_EPSILON, np.max(projected_values) + BOUNDS_EPSILON</span>
                <span class="c1"># BOUNDS[d,:] = np.min(coordinates[:,d]) - BOUNDS_EPSILON, np.max(coordinates[:,d]) + BOUNDS_EPSILON</span>

        <span class="n">projected_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">BASIS_VECTORS_INV</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)])</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span> <span class="n">BOUNDS</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">projected_values</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span> <span class="n">BOUNDS</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">projected_values</span> <span class="p">),</span>\
            <span class="s2">&quot;BOUNDS and coordinates do not fit together, did you set the correct grid_type argument?&quot;</span></div>


<div class="viewcode-block" id="RemovingSetWrapper"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.RemovingSetWrapper">[docs]</a><span class="k">class</span> <span class="nc">RemovingSetWrapper</span><span class="p">(</span><span class="nb">set</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RemovingSetWrapper removes elements on iteration.</span>

<span class="sd">    **Note:** Usually used internally only.</span>

<span class="sd">    When iterating over RemovingSetWrapper, the iterated element is removed.</span>
<span class="sd">    This manages basically which points are still needed to iterate over in the viability</span>
<span class="sd">    algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span></div>


<span class="k">def</span> <span class="nf">_viability_kernel_step</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> 
                          <span class="n">good_states</span><span class="p">,</span> <span class="n">bad_states</span><span class="p">,</span> <span class="n">succesful_states</span><span class="p">,</span> <span class="n">work_states</span><span class="p">,</span>
                          <span class="n">evolutions</span><span class="p">,</span> <span class="n">state_evaluation</span><span class="p">,</span>
                          <span class="n">use_numba</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">nb_nopython</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;do a single step of the viability calculation algorithm by checking which points stay immediately within the good_states&quot;&quot;&quot;</span>

    <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;use flattened grid, plz&quot;</span>
    <span class="n">max_index</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">viability_single_point</span> <span class="o">=</span> <span class="n">_generate_viability_single_point</span><span class="p">(</span><span class="n">evolutions</span><span class="p">,</span> <span class="n">state_evaluation</span><span class="p">,</span>
                                                              <span class="n">use_numba</span><span class="o">=</span><span class="n">use_numba</span><span class="p">,</span> <span class="n">nb_nopython</span><span class="o">=</span><span class="n">nb_nopython</span><span class="p">)</span>

    <span class="n">COUNTER</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">RemovingSetWrapper</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">max_index</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span> <span class="c1"># iterate over all indices and, if one is change, add the neighbors again (if necessary)</span>
        <span class="n">COUNTER</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">old_state</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">old_state</span> <span class="ow">in</span> <span class="n">work_states</span><span class="p">:</span>
            <span class="n">state_index</span> <span class="o">=</span> <span class="n">work_states</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">old_state</span><span class="p">)</span>
            <span class="n">succesful_state</span> <span class="o">=</span> <span class="n">succesful_states</span><span class="p">[</span><span class="n">state_index</span><span class="p">]</span>
            <span class="n">bad_state</span> <span class="o">=</span> <span class="n">bad_states</span><span class="p">[</span><span class="n">state_index</span><span class="p">]</span>
            <span class="n">new_state</span> <span class="o">=</span> <span class="n">viability_single_point</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">good_states</span><span class="p">,</span>
                                               <span class="n">succesful_state</span><span class="p">,</span> <span class="n">bad_state</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">new_state</span> <span class="o">!=</span> <span class="n">old_state</span><span class="p">:</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">states</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_state</span>
                <span class="c1"># get_neighbor_indices(index, shape, neighbor_list = neighbors)</span>
                <span class="n">get_neighbor_indices_via_cKD</span><span class="p">(</span><span class="n">index</span><span class="p">,</span>  <span class="n">neighbor_list</span><span class="o">=</span><span class="n">neighbors</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FINAL COUNTER&quot;</span><span class="p">,</span> <span class="n">COUNTER</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">changed</span>


<div class="viewcode-block" id="get_neighbor_indices_via_cKD"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.get_neighbor_indices_via_cKD">[docs]</a><span class="k">def</span> <span class="nf">get_neighbor_indices_via_cKD</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">neighbor_list</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;extend &#39;neighbor_list&#39; by all neighbors that are closer than STEPSIZE + BOUNDS_EPSILON</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">tree_neighbors</span> <span class="o">=</span> <span class="n">KDTREE</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">KDTREE</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">STEPSIZE</span> <span class="o">+</span> <span class="n">BOUNDS_EPSILON</span><span class="p">)</span>

    <span class="n">neighbor_list</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tree_neighbors</span><span class="p">)</span>
    <span class="c1"># neighbor_list.extend(tree_neighbors)</span>

    <span class="k">return</span> <span class="n">neighbor_list</span></div>


<span class="c1"># def get_neighbor_indices(index, shape, neighbor_list=[]):</span>
<span class="c1">#     &quot;&quot;&quot;append all neighboring indices of &#39;index&#39; to &#39;neighbor_list&#39; if they are within &#39;shape&#39;&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     index = np.asarray(index)</span>
<span class="c1">#     shape = np.asarray(shape)</span>
<span class="c1">#</span>
<span class="c1">#     for diff_index in it.product([-1, 0, 1], repeat=len(index)):</span>
<span class="c1">#         diff_index = np.asarray(diff_index)</span>
<span class="c1">#         new_index = index + diff_index</span>
<span class="c1">#</span>
<span class="c1">#         if np.count_nonzero(diff_index) and np.all( new_index &gt;= 0 ) and np.all( new_index &lt; shape ):</span>
<span class="c1">#             neighbor_list.append(tuple(new_index))</span>
<span class="c1">#</span>
<span class="c1">#     return neighbor_list</span>


<span class="k">def</span> <span class="nf">_viability_kernel</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> 
                     <span class="n">good_states</span><span class="p">,</span> <span class="n">bad_state</span><span class="p">,</span> <span class="n">succesful_state</span><span class="p">,</span> <span class="n">work_state</span><span class="p">,</span> <span class="n">evolutions</span><span class="p">,</span>
                     <span class="n">state_evaluation</span><span class="p">,</span>
                     <span class="n">periodic_boundaries</span><span class="o">=</span><span class="p">[]</span>
                     <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;calculate the viability kernel by iterating through the viability kernel steps</span>
<span class="sd">    until convergence (no further change)&quot;&quot;&quot;</span>
    <span class="c1"># assert coordinates.shape[:-1] == states.shape[:-1], &quot;&#39;coordinates&#39; and &#39;states&#39; don&#39;t match in shape&quot;</span>

    <span class="c1"># assert &quot;x_step&quot; in globals()  # needs to be set by the user for now ... will be changed later</span>
    <span class="k">assert</span> <span class="s2">&quot;BOUNDS_EPSILON&quot;</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span>  <span class="c1"># needs to be set by the user for now ... will be changed later</span>
    <span class="c1"># assert &quot;MAX_FINAL_DISTANCE&quot; in globals()  # needs to be set by the user for now ... will be changed later</span>
    <span class="k">assert</span> <span class="s2">&quot;MAX_NEIGHBOR_DISTANCE&quot;</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span>  <span class="c1"># needs to be set by the user for now ... will be changed later</span>
    <span class="k">assert</span> <span class="s2">&quot;STEPSIZE&quot;</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span>  <span class="c1"># as the above comments</span>
    <span class="c1"># global x_half_step</span>
    <span class="c1"># x_half_step = x_step/2</span>

    <span class="k">try</span><span class="p">:</span>
       <span class="n">work_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">work_state</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">work_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">work_state</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">succesful_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">succesful_state</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">succesful_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">succesful_state</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">bad_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bad_state</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">bad_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">bad_state</span><span class="p">]</span>

    <span class="c1"># actually only one step is needed due to the recursive checks (i.e. first</span>
    <span class="c1"># checking all neighbors of a point that changed state)</span>
    <span class="k">return</span> <span class="n">_viability_kernel_step</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> 
                                  <span class="n">good_states</span><span class="o">=</span><span class="n">good_states</span><span class="p">,</span> 
                                  <span class="n">bad_states</span><span class="o">=</span><span class="n">bad_states</span><span class="p">,</span> 
                                  <span class="n">succesful_states</span><span class="o">=</span><span class="n">succesful_states</span><span class="p">,</span> 
                                  <span class="n">work_states</span><span class="o">=</span><span class="n">work_states</span><span class="p">,</span> 
                                  <span class="n">evolutions</span><span class="o">=</span><span class="n">evolutions</span><span class="p">,</span> 
                                  <span class="n">state_evaluation</span><span class="o">=</span><span class="n">state_evaluation</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_viability_capture_basin</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                            <span class="n">target_states</span><span class="p">,</span> <span class="n">reached_state</span><span class="p">,</span> <span class="n">bad_state</span><span class="p">,</span> <span class="n">work_state</span><span class="p">,</span> <span class="n">evolutions</span><span class="p">,</span>
                            <span class="n">state_evaluation</span><span class="o">=</span><span class="n">state_evaluation_kdtree</span>
                            <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;reuse the viability kernel algorithm to calculate the capture basin&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">work_state</span> <span class="ow">in</span> <span class="n">states</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span> <span class="p">(</span> <span class="n">target_state</span> <span class="ow">in</span> <span class="n">states</span> <span class="k">for</span> <span class="n">target_state</span> <span class="ow">in</span> <span class="n">target_states</span><span class="p">)</span> <span class="p">):</span>
        <span class="c1"># num_work = np.count_nonzero(work_state == states)</span>
        <span class="n">_viability_kernel</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> 
                         <span class="n">good_states</span><span class="o">=</span><span class="n">target_states</span> <span class="o">+</span> <span class="p">[</span><span class="n">reached_state</span><span class="p">],</span> 
                         <span class="n">bad_state</span><span class="o">=</span><span class="n">work_state</span><span class="p">,</span> 
                         <span class="n">succesful_state</span><span class="o">=</span><span class="n">reached_state</span><span class="p">,</span>
                         <span class="n">work_state</span><span class="o">=</span><span class="n">work_state</span><span class="p">,</span> 
                         <span class="n">evolutions</span><span class="o">=</span><span class="n">evolutions</span><span class="p">,</span> 
                         <span class="n">state_evaluation</span><span class="o">=</span><span class="n">state_evaluation</span>
                         <span class="p">)</span>
        <span class="c1"># changed = (num_work == np.count_nonzero(reached_state == states))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">printv</span><span class="p">(</span><span class="s2">&quot;capture basin: empty work or target set&quot;</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># changed = False</span>
    <span class="c1"># all the points that still have the state work_state are not part of the capture basin and are set to be bad_states</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="p">(</span><span class="n">work_state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">)</span>
    <span class="n">states</span><span class="p">[</span> <span class="n">states</span> <span class="o">==</span> <span class="n">work_state</span> <span class="p">]</span> <span class="o">=</span> <span class="n">bad_state</span>
    <span class="k">return</span> <span class="n">changed</span>

<span class="c1"># below are just helper functions</span>


<div class="viewcode-block" id="print_evaluation"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.print_evaluation">[docs]</a><span class="k">def</span> <span class="nf">print_evaluation</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">print_empty_regions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">print_unknown</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print an Evaluation of the results of an TSM-Computation.&quot;&quot;&quot;</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">states</span><span class="o">.</span><span class="n">size</span>
    <span class="n">total_length</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">total</span><span class="p">)))</span>
    <span class="n">num_sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">current_globals</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Evaluation (relative normalized Volume):&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">REGIONS</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="n">current_globals</span><span class="p">[</span><span class="n">region</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">print_empty_regions</span> <span class="ow">or</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_sum</span> <span class="o">+=</span> <span class="n">num</span>
            <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="si">{:&lt;13}</span><span class="s2"> (</span><span class="si">{:&gt;2}</span><span class="s2">): </span><span class="si">{:&gt;6.2f}</span><span class="s2">% ( {:&gt;&quot;</span><span class="o">+</span><span class="n">total_length</span><span class="o">+</span><span class="s2">&quot;} )&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">region</span><span class="p">],</span>  <span class="n">num</span> <span class="o">/</span> <span class="n">total</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">print_unknown</span> <span class="ow">and</span> <span class="n">num_sum</span> <span class="o">!=</span> <span class="n">total</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="si">{:&lt;15}</span><span class="s2">: </span><span class="si">{:&gt;6.2f}</span><span class="s2">% ( {:&gt;&quot;</span><span class="o">+</span><span class="n">total_length</span><span class="o">+</span><span class="s2">&quot;} )&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;UNKNOWN&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="n">total</span> <span class="o">-</span> <span class="n">num_sum</span><span class="p">)</span> <span class="o">/</span> <span class="n">total</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="n">total</span> <span class="o">-</span> <span class="n">num_sum</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">()</span></div>


<div class="viewcode-block" id="plot_points"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.plot_points">[docs]</a><span class="k">def</span> <span class="nf">plot_points</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">plot_unset</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;plot the current states in the viability calculation as points&quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">COLORS</span><span class="p">)</span>

    <span class="n">plot_colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">COLORS</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_unset</span><span class="p">:</span>
        <span class="n">plot_colors</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">UNSET</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">color_state</span> <span class="ow">in</span> <span class="n">plot_colors</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span> <span class="n">states</span> <span class="o">==</span> <span class="n">color_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span> <span class="n">states</span> <span class="o">==</span> <span class="n">color_state</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">COLORS</span><span class="p">[</span><span class="n">color_state</span><span class="p">],</span>
                 <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_areas"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.plot_areas">[docs]</a><span class="k">def</span> <span class="nf">plot_areas</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;plot the current states in the viability calculation as areas&quot;&quot;&quot;</span>

    <span class="n">states</span> <span class="o">=</span> <span class="n">states</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">states</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">COLORS</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">states</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">color_states</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">COLORS</span><span class="p">)</span>
    <span class="n">cmap</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">([</span> <span class="n">COLORS</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">color_states</span> <span class="p">])</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="n">color_states</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span> <span class="n">state</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">color_states</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">color_states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">BoundaryNorm</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">cmap</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tripcolor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="s2">&quot;gouraud&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="make_run_function"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.make_run_function">[docs]</a><span class="k">def</span> <span class="nf">make_run_function</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span>
                      <span class="n">ordered_params</span><span class="p">,</span>
                      <span class="n">offset</span><span class="p">,</span>
                      <span class="n">scaling_vector</span><span class="p">,</span>
                      <span class="n">returning</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                      <span class="n">use_numba</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">nb_nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">rescaling_epsilon</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span>
                      <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a *run-function* from a right-hand side of an ordinary differential equation.</span>

<span class="sd">    The *run-function* takes a starting point and a time and returns a trajectory that</span>
<span class="sd">    follows the corresponding ODE. It basically provides the step from a generic ODE to</span>
<span class="sd">    a map that gives the next point. The reason the return value is actually a trajectory</span>
<span class="sd">    and not just the next point is simply future compatibility.</span>

<span class="sd">    **Note:** This function automatically rescales the RHS to work on [0, 1]^dim and homogenizes</span>
<span class="sd">    the time (see https://arxiv.org/abs/1706.04542).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rhs : callable</span>
<span class="sd">        Function that representes the RHS of the ODE. The first two arguments should be</span>
<span class="sd">        the point `x` in state space and the time `t`. The following arguments should be</span>
<span class="sd">        parameters that are need to be given, if necessary.</span>
<span class="sd">    ordered_params : tuple</span>
<span class="sd">        The parameters needed for rhs.</span>
<span class="sd">    offset : array-like</span>
<span class="sd">        output from grid rescaling, see `generate_grid`</span>
<span class="sd">    scaling_vector : array-like</span>
<span class="sd">        output from grid rescaling, see `generate_grid`</span>
<span class="sd">    returning : str, default : &quot;linear&quot;</span>
<span class="sd">        only change of you know what you do</span>
<span class="sd">    use_numa : bool, default : True</span>
<span class="sd">        Should numba be used?</span>
<span class="sd">    nb_nb_nopython : bool, default : True,</span>
<span class="sd">        If numba is used, force nopython-mode?</span>
<span class="sd">    rescaling_rescaling_epsilon :  float, default : 1e-6</span>
<span class="sd">        When homogenizing the time, which \epsilong value should be used. see https://arxiv.org/abs/1706.04542</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable</span>
<span class="sd">        The corresponding run-function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scaling_vector</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">Sinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------</span>

    <span class="k">def</span> <span class="nf">rhs_scaled_to_one_PS</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        for 2D plotting of the whole phase space plot</span>
<span class="sd">        rescales space only, because that should be enough for the phase space plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">offset</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">Sinv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)])</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">ordered_params</span><span class="p">)</span>  <span class="c1"># calculate the rhs</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)])</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="c1"># ----------------------------------------</span>

    <span class="k">if</span> <span class="n">use_numba</span><span class="p">:</span>
        <span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="n">nb_nopython</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">rhs_rescaled</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

            <span class="c1"># because of the rescaling to 1 in every dimension</span>
            <span class="c1"># transforming y -&gt; x</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">+=</span> <span class="n">Sinv</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># x += Sinv[:, i] * y[i]</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="c1"># transforming dx -&gt; dy</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">dy</span> <span class="o">+=</span> <span class="n">S</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># dy += S[:, i] * dx[i]</span>

            <span class="c1"># normalization of dy</span>
            <span class="n">dy_norm</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">dy_norm</span> <span class="o">+=</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">dy_norm</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dy_norm</span><span class="p">)</span>

            <span class="c1"># check whether it&#39;s a fixed point</span>
            <span class="k">if</span> <span class="n">dy_norm</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">dy</span> <span class="o">/</span> <span class="p">(</span><span class="n">dy_norm</span> <span class="o">+</span> <span class="n">rescaling_epsilon</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">rhs_rescaled</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="c1"># because of the rescaling to 1 in every dimension</span>
            <span class="c1"># transforming y -&gt; x</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sinv</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="c1"># transforming dx -&gt; dy</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">rhs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>  <span class="c1"># calculate the rhs</span>
            <span class="c1"># normalization of dy</span>
            <span class="n">dy_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dy</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">dy_norm</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dy</span> <span class="o">/</span> <span class="p">(</span><span class="n">dy_norm</span> <span class="o">+</span> <span class="n">rescaling_epsilon</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_numba</span><span class="p">:</span>
        <span class="nd">@nb</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="n">nb_nopython</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">normalized_linear_approximation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
            <span class="n">xdot</span> <span class="o">=</span> <span class="n">rhs_rescaled</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="o">*</span><span class="n">ordered_params</span><span class="p">)</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">traj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">xdot</span><span class="p">)):</span>  <span class="c1"># raise artifiially the warning if inf turns up</span>
                <span class="c1"># warn.warn(&quot;got a inf in the RHS function; assume {!s} to be a stable fixed point and returning the starting point&quot;.format(x),</span>
                        <span class="c1"># category=RuntimeWarning)</span>
                <span class="n">traj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">traj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xdot</span><span class="o">*</span><span class="n">dt</span>
            <span class="k">return</span> <span class="n">traj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">normalized_linear_approximation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
            <span class="n">xdot</span> <span class="o">=</span> <span class="n">rhs_rescaled</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="o">*</span><span class="n">ordered_params</span><span class="p">)</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xdot</span><span class="o">*</span><span class="n">dt</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">xdot</span><span class="p">)):</span>  <span class="c1"># raise artifiially the warning if inf turns up</span>
                <span class="n">warn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;got a inf in the RHS function; assume </span><span class="si">{!s}</span><span class="s2"> to be a stable fixed point and returning the starting point&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                          <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="n">traj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">DEBUGGING</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># plot the point, but a bit larger than the color one later</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                             <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">DEBUGGING</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">traj</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">traj</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">traj</span>

    <span class="c1"># @nb.jit</span>
    <span class="c1"># def distance_normalized_rhs(x, lam, x0, *args):</span>
        <span class="c1"># val = rhs_scaled_to_one(x, lam, *args)  # calculate the rhs</span>
        <span class="c1"># if lam == 0:</span>
            <span class="c1"># return val / np.sqrt(np.sum( val ** 2, axis=-1) )</span>
        <span class="c1"># return val * lam / np.sum( (x-x0) * val, axis=-1)</span>

    <span class="c1"># @helper.remembering(remember=remember)</span>
    <span class="c1"># def integration(p, stepsize):</span>
        <span class="c1"># if DEBUGGING:</span>
            <span class="c1"># integ_time = np.linspace(0, stepsize, 100)</span>
        <span class="c1"># else:</span>
            <span class="c1"># integ_time = [0, stepsize]</span>
        <span class="c1"># try:</span>
            <span class="c1"># with helper.stdout_redirected():</span>
                <span class="c1"># traj = integ.odeint(distance_normalized_rhs, p, integ_time,</span>
                                    <span class="c1"># args=(p,) + ordered_params,</span>
                                    <span class="c1"># printmessg = False</span>
                                    <span class="c1"># )</span>
            <span class="c1"># if np.any(np.isnan(traj[-1])): # raise artifiially the warning if nan turns up</span>
                <span class="c1"># raise integ.odepack.ODEintWarning(&quot;got a nan&quot;)</span>
        <span class="c1"># except integ.odepack.ODEintWarning:</span>
            <span class="c1"># warn.warn(&quot;got an integration warning; assume {!s} to be a stable fixed point and returning the starting point&quot;.format(p),</span>
                      <span class="c1"># category=RuntimeWarning)</span>
            <span class="c1"># if DEBUGGING:</span>
                <span class="c1"># # plot the point, but a bit larger than the color one later</span>
                <span class="c1"># plt.plot(p[0], p[1], color = &quot;red&quot;,</span>
                    <span class="c1"># linestyle = &quot;&quot;, marker = &quot;.&quot;, markersize = 45 ,zorder=0)</span>
            <span class="c1"># return np.asarray([p, p])</span>
<span class="c1">#</span>
        <span class="c1"># if DEBUGGING:</span>
            <span class="c1"># plt.plot(traj[:, 0], traj[:, 1], color=&quot;red&quot;, linewidth=3)</span>
            <span class="c1"># return np.asarray([traj[0], traj[-1]])</span>
        <span class="c1"># else:</span>
            <span class="c1"># return traj</span>

    <span class="k">if</span> <span class="n">returning</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">normalized_linear_approximation</span>
    <span class="k">elif</span> <span class="n">returning</span> <span class="o">==</span> <span class="s2">&quot;PS&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rhs_scaled_to_one_PS</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;I don&#39;t know what to do with returning=</span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">returning</span><span class="p">))</span></div>


<div class="viewcode-block" id="scaled_to_one_sunny"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.scaled_to_one_sunny">[docs]</a><span class="k">def</span> <span class="nf">scaled_to_one_sunny</span><span class="p">(</span><span class="n">is_sunny</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">scaling_vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Scale the is_sunny function so it operates on [0, 1]^dim.&quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">scaling_vector</span>
    <span class="n">Sinv</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">scaled_sunny</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="n">new_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">Sinv</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># new_grid = backscaling_grid(grid, scaling_vector, offset)</span>
        <span class="c1"># new_grid = np.dot(Sinv, grid) + offset</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">is_sunny</span><span class="p">(</span><span class="n">new_grid</span><span class="p">)</span>  <span class="c1"># calculate the rhs</span>
        <span class="k">return</span> <span class="n">val</span>  <span class="c1"># normalize it</span>

    <span class="k">return</span> <span class="n">scaled_sunny</span></div>


<span class="c1"># def trajectory_length(traj):</span>
<span class="c1">#     return np.sum( la.norm( traj[1:] - traj[:-1], axis=-1) )</span>


<span class="c1"># def trajectory_length_index(traj, target_length):</span>
<span class="c1">#     lengths = np.cumsum( la.norm( traj[1:] - traj[:-1], axis=-1) )</span>
<span class="c1">#</span>
<span class="c1">#     if target_length &lt; lengths[-1]:</span>
<span class="c1">#         return traj.shape[0]  # incl. last element</span>
<span class="c1">#     index_0, index_1 = 0, traj.shape[0] - 1</span>
<span class="c1">#</span>
<span class="c1">#     while index_0 not in [index_1, index_1 - 1]:</span>
<span class="c1">#         middle_index = int( (index_0 + index_1)/2 )</span>
<span class="c1">#</span>
<span class="c1">#         if lengths[middle_index] &lt;= target_length:</span>
<span class="c1">#             index_0 = middle_index</span>
<span class="c1">#         else:</span>
<span class="c1">#             index_1 = middle_index</span>
<span class="c1">#</span>
<span class="c1">#     return index_1</span>


<div class="viewcode-block" id="backscaling_grid"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.backscaling_grid">[docs]</a><span class="k">def</span> <span class="nf">backscaling_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">scaling_vector</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Scale a grid back( after computation) from [0, 1]^dim to the original state space.&quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">scaling_vector</span>
    <span class="n">Sinv</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">new_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">Sinv</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)])</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">new_grid</span></div>


<span class="k">def</span> <span class="nf">reset_initial_states</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
    <span class="c1"># All initially given states are set to positive counterparts</span>
    <span class="c1"># coordinates is given because this is the standard for a post_computation_hook of topology_classification (see there)</span>
    <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">&lt;</span> <span class="n">UNSET</span><span class="p">)]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>


<div class="viewcode-block" id="set_global_status"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.set_global_status">[docs]</a><span class="k">def</span> <span class="nf">set_global_status</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">print_verbosity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Setting the global Status of a Computation so it can be read out in case of Errors.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">STATUS_PREFIX</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;STATUS_PREFIX has to be set, maybe you found a bug?&quot;</span>
    <span class="k">global</span> <span class="n">STATUS</span>
    <span class="n">STATUS</span> <span class="o">=</span> <span class="n">STATUS_INFIX</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">STATUS_PREFIX</span><span class="p">,)</span> <span class="o">+</span> <span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_verbosity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">print_verbosity</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">STATUS_PREFIX</span> <span class="o">==</span> <span class="n">STATUS_TOPOLOGY</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">STATUS_PREPARATION</span><span class="p">:</span>
                <span class="n">print_verbosity</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">printv</span><span class="p">(</span><span class="n">STATUS</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="n">print_verbosity</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_global_status"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.get_global_status">[docs]</a><span class="k">def</span> <span class="nf">get_global_status</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the current Status of a computation.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">STATUS</span></div>


<div class="viewcode-block" id="topology_classification"><a class="viewcode-back" href="../../pyviability.libviability.html#pyviability.libviability.topology_classification">[docs]</a><span class="k">def</span> <span class="nf">topology_classification</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">default_evols</span><span class="p">,</span> <span class="n">management_evols</span><span class="p">,</span> <span class="n">is_sunny</span><span class="p">,</span>
                            <span class="n">periodic_boundaries</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">compute_eddies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">pre_calculation_hook</span><span class="o">=</span><span class="n">pre_calculation_hook_kdtree</span><span class="p">,</span>  <span class="c1"># None means nothing to be done</span>
                            <span class="n">state_evaluation</span><span class="o">=</span><span class="n">state_evaluation_kdtree</span><span class="p">,</span>
                            <span class="n">post_computation_hook</span><span class="o">=</span><span class="n">reset_initial_states</span><span class="p">,</span>
                            <span class="n">grid_type</span><span class="o">=</span><span class="s2">&quot;orthogonal&quot;</span><span class="p">,</span>
                            <span class="n">out_of_bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># either bool or bool array with shape (dim, ) or shape (dim, 2) with values for each boundary</span>
                            <span class="n">remember_paths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">stop_when_finished</span><span class="o">=</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># means everything goes</span>
                            <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate different regions of the state space using viability theory algorithms.</span>

<span class="sd">    This function computes the Topology of Sustainable Management (TSM) classification of the state space (see [1] for mathematical details).</span>

<span class="sd">    The first application can be found in [2].</span>

<span class="sd">    [1] http://www.earth-syst-dynam.net/7/21/2016/esd-7-21-2016.html</span>

<span class="sd">    [2] https://arxiv.org/abs/1706.04542</span>

<span class="sd">    *Note:* A `state` is an integer referring to a certain region (in the sense of TSM), corresponding as to how they are defined in the header of this file</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coordinates : array-like</span>
<span class="sd">        Grid used for the computation, shape (n0, dim) where n0 is the total number of points and dim the dimension of the system</span>
<span class="sd">    states : array-like</span>
<span class="sd">        associates to each grid point the corresponding state. negative values correspond to preset values given by the user. **The results will be saved in here.**</span>
<span class="sd">    compute_eddies : bool, default : True</span>
<span class="sd">        Should the Eddies be computed as well. As indicated in [2], this may take quite a bit of computational power and is hence switched of generally.</span>
<span class="sd">    pre_pre_calculation_hook : callable, default : pre_pre_calculation_hook_kdtree</span>
<span class="sd">        ignore if you don&#39;t know what to do</span>
<span class="sd">    state_evaluation : callable, default : state_evaluation_kdtree</span>
<span class="sd">        ignore if you don&#39;t know what to do</span>
<span class="sd">    post_computation_hook : callable, default : reset_initial_states</span>
<span class="sd">        ignore if you don&#39;t know what to do</span>
<span class="sd">    grid_type : str, default : &quot;orthogonal&quot;</span>
<span class="sd">    out_of_bounds : bool, default : True</span>
<span class="sd">        Is outside of the grid a undesirable region (in the sense of TSM)?</span>
<span class="sd">    remember_paths : bool, default : False</span>
<span class="sd">        Remember the paths that have been used. This is actually more of a hack and should not really be used.</span>
<span class="sd">    verbosity : int, default : 0</span>
<span class="sd">    stop_when_finished : str, default : &#39;&#39;</span>
<span class="sd">        For Debugging only: stop when a certain operation has finished. See TOPOLOGY_STEP_LIST for the list of possible values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">VERBOSITY</span>
    <span class="n">VERBOSITY</span> <span class="o">=</span> <span class="n">verbosity</span>

    <span class="k">global</span> <span class="n">STATUS_PREFIX</span>
    <span class="n">STATUS_PREFIX</span> <span class="o">=</span> <span class="n">STATUS_TOPOLOGY</span>
    <span class="n">current_step</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_PREPARATION</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop_when_finished</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">stop_when_finished</span> <span class="o">=</span> <span class="n">TOPOLOGY_STEP_LIST</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">stop_when_finished</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop_when_finished</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stop_when_finished</span> <span class="o">&gt;=</span> <span class="mi">0</span>

    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

    <span class="n">grid_size</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">states</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">grid_size</span><span class="p">,),</span> <span class="s2">&quot;coordinates and states input doesn&#39;t match&quot;</span>


    <span class="k">if</span> <span class="n">remember_paths</span><span class="p">:</span>
        <span class="n">printv</span><span class="p">(</span><span class="s2">&quot;generating PATHS and PATHS_LAKE arrays&quot;</span><span class="p">)</span>
        <span class="k">global</span> <span class="n">PATHS</span><span class="p">,</span> <span class="n">PATHS_LAKE</span>
        <span class="n">PATHS</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;reached point&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>  <span class="c1"># for the target point</span>
        <span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;next point index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">grid_size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PATHS_INDEX_TYPE</span><span class="p">)</span> <span class="o">*</span> <span class="n">PATHS_INDEX_DEFAULT</span>  <span class="c1"># the coordinate where the target point get&#39;s associated to</span>
        <span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;choice&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">grid_size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">PATHS_MANAGEMENT_TYPE</span><span class="p">)</span> <span class="o">*</span> <span class="n">PATHS_MANAGEMENT_DEFAULT</span>  <span class="c1"># for the number of the management option</span>

        <span class="n">PATHS_LAKE</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">PATHS_LAKE</span><span class="p">[</span><span class="s2">&quot;reached point&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;reached point&quot;</span><span class="p">])</span>
        <span class="n">PATHS_LAKE</span><span class="p">[</span><span class="s2">&quot;next point index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;next point index&quot;</span><span class="p">])</span>
        <span class="n">PATHS_LAKE</span><span class="p">[</span><span class="s2">&quot;choice&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;choice&quot;</span><span class="p">])</span>

        <span class="c1"># PATHS = (np.copy(coordinates),  # for the target point</span>
                 <span class="c1"># -np.ones((grid_size,), dtype=int),  # the coordinate where the target point get&#39;s associated to</span>
                 <span class="c1"># -np.ones((grid_size,), dtype=np.int16) )  # for the number of the management option</span>

    <span class="k">if</span> <span class="n">periodic_boundaries</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">periodic_boundaries</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">periodic_boundaries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">periodic_boundaries</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pre_calculation_hook</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># run the pre-calculation hook (defaults to creation of the KD-Tree)</span>
        <span class="n">pre_calculation_hook</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span>
                             <span class="n">is_sunny</span><span class="o">=</span><span class="n">is_sunny</span><span class="p">,</span>
                             <span class="n">periodicity</span><span class="o">=</span><span class="n">periodic_boundaries</span><span class="p">,</span>
                             <span class="n">grid_type</span><span class="o">=</span><span class="n">grid_type</span><span class="p">,</span>
                             <span class="n">out_of_bounds</span><span class="o">=</span><span class="n">out_of_bounds</span><span class="p">)</span>

    <span class="c1"># make sure, evols can be treated as lists</span>
    <span class="n">default_evols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">default_evols</span><span class="p">)</span>
    <span class="n">management_evols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">management_evols</span><span class="p">)</span>

    <span class="n">all_evols</span> <span class="o">=</span> <span class="n">default_evols</span> <span class="o">+</span> <span class="n">management_evols</span>

    <span class="c1"># better remove this and use directly the lower level stuff, see issue #13</span>
    <span class="n">viability_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">state_evaluation</span><span class="o">=</span><span class="n">state_evaluation</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># shelter_empty = False</span>
    <span class="c1"># backwater_empty = False</span>

    <span class="k">if</span> <span class="n">all_evols</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">default_evols</span><span class="p">:</span>
            <span class="n">printv</span><span class="p">(</span><span class="s1">&#39;no default dynamics given, skipping upstream&#39;</span><span class="p">)</span>
            <span class="n">current_step</span> <span class="o">+=</span> <span class="mi">3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># shelter computation</span>
            <span class="n">current_step</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_PREPARATION</span><span class="p">)</span>
            <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">==</span> <span class="n">UNSET</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">is_sunny</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)]</span> <span class="o">=</span> <span class="n">SHELTER</span>  <span class="c1"># initial state for shelter calculation</span>
            <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">)</span>
            <span class="n">_viability_kernel</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> 
                    <span class="n">good_states</span><span class="o">=</span><span class="p">[</span><span class="n">SHELTER</span><span class="p">,</span> <span class="o">-</span><span class="n">SHELTER</span><span class="p">],</span> 
                    <span class="n">bad_state</span><span class="o">=</span><span class="n">UNSET</span><span class="p">,</span> 
                    <span class="n">succesful_state</span><span class="o">=</span><span class="n">SHELTER</span><span class="p">,</span> 
                    <span class="n">work_state</span><span class="o">=</span><span class="n">SHELTER</span><span class="p">,</span> 
                    <span class="n">evolutions</span><span class="o">=</span><span class="n">default_evols</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">viability_kwargs</span><span class="p">)</span>
            <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_DONE</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stop_when_finished</span> <span class="o">==</span> <span class="s2">&quot;shelter&quot;</span><span class="p">:</span>
                <span class="c1"># do the post computation hook (default, setting negative states positive)</span>
                <span class="c1"># and then exit</span>
                <span class="n">post_computation_hook</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
                <span class="k">return</span> 

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="n">SHELTER</span><span class="p">):</span>  <span class="c1"># shelter is empty?</span>
                <span class="n">printv</span><span class="p">(</span><span class="s1">&#39;shelter empty, skip rest of upstream&#39;</span><span class="p">)</span>
                <span class="n">current_step</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_step</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">management_evols</span><span class="p">:</span>
                    <span class="n">printv</span><span class="p">(</span><span class="s1">&#39;no management dynamics given, skipping glade&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_PREPARATION</span><span class="p">)</span>
                    <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">==</span> <span class="n">UNSET</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">is_sunny</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)]</span> <span class="o">=</span> <span class="n">SUNNY_UP</span>

                    <span class="c1"># glade computation</span>
                    <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">)</span>
                    <span class="n">_viability_capture_basin</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> 
                            <span class="n">target_states</span><span class="o">=</span><span class="p">[</span><span class="n">SHELTER</span><span class="p">,</span> <span class="o">-</span><span class="n">SHELTER</span><span class="p">],</span> 
                            <span class="n">reached_state</span><span class="o">=</span><span class="n">GLADE</span><span class="p">,</span> 
                            <span class="n">bad_state</span><span class="o">=</span><span class="n">UNSET</span><span class="p">,</span> 
                            <span class="n">work_state</span><span class="o">=</span><span class="n">SUNNY_UP</span><span class="p">,</span> 
                            <span class="n">evolutions</span><span class="o">=</span><span class="n">all_evols</span><span class="p">,</span> <span class="o">**</span><span class="n">viability_kwargs</span><span class="p">)</span>
                    <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_DONE</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">stop_when_finished</span> <span class="o">&lt;=</span> <span class="n">current_step</span><span class="p">:</span>
                    <span class="c1"># do the post computation hook (default, setting negative states positive)</span>
                    <span class="c1"># and then exit</span>
                    <span class="n">post_computation_hook</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
                    <span class="k">return</span> 

                <span class="n">current_step</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># computation remaining upstream dark and sunny (containing possible lake)</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_PREPARATION</span><span class="p">)</span>
                <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">==</span> <span class="n">UNSET</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DARK_UP</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">)</span>
                <span class="n">_viability_capture_basin</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> 
                                        <span class="n">target_states</span><span class="o">=</span><span class="p">[</span><span class="n">SHELTER</span><span class="p">,</span> <span class="o">-</span><span class="n">SHELTER</span><span class="p">,</span> <span class="n">GLADE</span><span class="p">,</span> <span class="o">-</span><span class="n">GLADE</span><span class="p">,</span> <span class="o">-</span><span class="n">SUNNY_UP</span><span class="p">,</span> <span class="o">-</span><span class="n">DARK_UP</span><span class="p">,</span> <span class="o">-</span><span class="n">LAKE</span><span class="p">],</span> 
                                        <span class="n">reached_state</span><span class="o">=</span><span class="n">SUNNY_UP</span><span class="p">,</span> 
                                        <span class="n">bad_state</span><span class="o">=</span><span class="n">UNSET</span><span class="p">,</span> 
                                        <span class="n">work_state</span><span class="o">=</span><span class="n">DARK_UP</span><span class="p">,</span> 
                                        <span class="n">evolutions</span><span class="o">=</span><span class="n">all_evols</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">viability_kwargs</span><span class="p">)</span>

                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_POSTPROCESSING</span><span class="p">)</span>
                <span class="n">states</span><span class="p">[</span><span class="o">~</span><span class="n">is_sunny</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="n">SUNNY_UP</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DARK_UP</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_DONE</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">current_step</span> <span class="o">==</span> <span class="n">TOPOLOGY_STEP_LIST</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;REMUP&quot;</span><span class="p">),</span> <span class="s2">&quot;consistency check failed, bug? (</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_step</span><span class="p">,</span> <span class="n">TOPOLOGY_STEP_LIST</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;REMUP&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">stop_when_finished</span> <span class="o">&lt;=</span> <span class="n">current_step</span><span class="p">:</span>
            <span class="c1"># do the post computation hook (default, setting negative states positive)</span>
            <span class="c1"># and then exit</span>
            <span class="n">post_computation_hook</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
            <span class="k">return</span> 


        <span class="k">if</span> <span class="ow">not</span> <span class="n">management_evols</span><span class="p">:</span>
            <span class="n">printv</span><span class="p">(</span><span class="s1">&#39;no management dynamics given, skipping lake and downstream&#39;</span><span class="p">)</span>
            <span class="n">current_step</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_step</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">current_step</span> <span class="o">==</span> <span class="n">TOPOLOGY_STEP_LIST</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;MANAGEABLE&quot;</span><span class="p">),</span> <span class="s2">&quot;consistency check failed, bug? (</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_step</span><span class="p">,</span> <span class="n">TOPOLOGY_STEP_LIST</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;MANAGEABLE&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">remember_paths</span><span class="p">:</span>
                <span class="n">_PATHS</span> <span class="o">=</span> <span class="n">PATHS</span>
                <span class="n">PATHS</span> <span class="o">=</span> <span class="n">PATHS_LAKE</span>
            <span class="c1"># compute rest of manageable region (lake + backwaters)</span>
            <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_PREPARATION</span><span class="p">)</span>
            <span class="n">states</span><span class="p">[</span><span class="n">is_sunny</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="n">SUNNY_UP</span><span class="p">)]</span> <span class="o">=</span> <span class="n">LAKE</span>
            <span class="n">states</span><span class="p">[</span><span class="n">is_sunny</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="n">UNSET</span><span class="p">)]</span> <span class="o">=</span> <span class="n">BACKWATERS</span>
            <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">)</span>
            <span class="n">_viability_kernel</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> 
                    <span class="n">good_states</span><span class="o">=</span><span class="p">[</span>
                                 <span class="n">SHELTER</span><span class="p">,</span> <span class="o">-</span><span class="n">SHELTER</span><span class="p">,</span>  <span class="c1"># these should not be possible to be reached</span>
                                 <span class="n">GLADE</span><span class="p">,</span> <span class="o">-</span><span class="n">GLADE</span><span class="p">,</span>  <span class="c1"># these should not be possible to be reached</span>
                                 <span class="n">LAKE</span><span class="p">,</span> <span class="o">-</span><span class="n">LAKE</span><span class="p">,</span>
                                 <span class="n">BACKWATERS</span><span class="p">,</span> <span class="o">-</span><span class="n">BACKWATERS</span>
                                 <span class="p">],</span> 
                    <span class="n">bad_state</span><span class="o">=</span><span class="p">[</span><span class="n">SUNNY_UP</span><span class="p">,</span> <span class="n">UNSET</span><span class="p">],</span> 
                    <span class="n">succesful_state</span><span class="o">=</span><span class="p">[</span><span class="n">LAKE</span><span class="p">,</span> <span class="n">BACKWATERS</span><span class="p">],</span> 
                    <span class="n">work_state</span><span class="o">=</span><span class="p">[</span><span class="n">LAKE</span><span class="p">,</span> <span class="n">BACKWATERS</span><span class="p">],</span> 
                    <span class="n">evolutions</span><span class="o">=</span><span class="n">all_evols</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">viability_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">remember_paths</span><span class="p">:</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_POSTPROCESSING</span><span class="p">)</span>
                <span class="n">PATHS</span> <span class="o">=</span> <span class="n">_PATHS</span>
                <span class="c1"># don&#39;t need to set back PATHS_LAKE as these are just references to the dictionaries anyway</span>
                <span class="k">del</span> <span class="n">_PATHS</span>  <span class="c1"># just for keeping the code clean, not really necessary</span>

                <span class="c1"># write the backwaters part to the normal mask</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="n">BACKWATERS</span><span class="p">)</span>
                <span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;reached point&quot;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">PATHS_LAKE</span><span class="p">[</span><span class="s2">&quot;reached point&quot;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;next point index&quot;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">PATHS_LAKE</span><span class="p">[</span><span class="s2">&quot;next point index&quot;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">PATHS</span><span class="p">[</span><span class="s2">&quot;choice&quot;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">PATHS_LAKE</span><span class="p">[</span><span class="s2">&quot;choice&quot;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">PATHS_LAKE</span><span class="p">[</span><span class="s2">&quot;next point index&quot;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">PATHS_INDEX_DEFAULT</span>
                <span class="n">PATHS_LAKE</span><span class="p">[</span><span class="s2">&quot;choice&quot;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">PATHS_MANAGEMENT_DEFAULT</span>
                <span class="k">del</span> <span class="n">mask</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="n">LAKE</span><span class="p">):</span>
                    <span class="n">printv</span><span class="p">(</span><span class="s2">&quot;no lake found, removing PATHS_LAKE arrays&quot;</span><span class="p">)</span>
                    <span class="n">PATHS_LAKE</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_DONE</span><span class="p">)</span>


            <span class="k">if</span> <span class="n">stop_when_finished</span> <span class="o">&lt;=</span> <span class="n">current_step</span><span class="p">:</span>
                <span class="c1"># do the post computation hook (default, setting negative states positive)</span>
                <span class="c1"># and then exit</span>
                <span class="n">post_computation_hook</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
                <span class="k">return</span> 


            <span class="n">current_step</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="n">BACKWATERS</span><span class="p">):</span>
                <span class="n">printv</span><span class="p">(</span><span class="s1">&#39;backwater empty, skip remaining downstream&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># calculate remaining downstream dark and sunny</span>
                <span class="k">assert</span> <span class="n">current_step</span> <span class="o">==</span> <span class="n">TOPOLOGY_STEP_LIST</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;REMDOWN&quot;</span><span class="p">),</span> <span class="s2">&quot;consistency check failed, bug? (</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_step</span><span class="p">,</span> <span class="n">TOPOLOGY_STEP_LIST</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;REMDOWN&quot;</span><span class="p">))</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_PREPARATION</span><span class="p">)</span>
                <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">==</span> <span class="n">UNSET</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DARK_DOWN</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">)</span>
                <span class="n">_viability_capture_basin</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> 
                        <span class="n">target_states</span><span class="o">=</span><span class="p">[</span><span class="n">BACKWATERS</span><span class="p">,</span> <span class="o">-</span><span class="n">SUNNY_DOWN</span><span class="p">,</span> <span class="o">-</span><span class="n">DARK_DOWN</span><span class="p">],</span> 
                        <span class="n">reached_state</span><span class="o">=</span><span class="n">SUNNY_DOWN</span><span class="p">,</span> 
                        <span class="n">bad_state</span><span class="o">=</span><span class="n">UNSET</span><span class="p">,</span> 
                        <span class="n">work_state</span><span class="o">=</span><span class="n">DARK_DOWN</span><span class="p">,</span> 
                        <span class="n">evolutions</span><span class="o">=</span><span class="n">all_evols</span><span class="p">,</span> 
                        <span class="o">**</span><span class="n">viability_kwargs</span><span class="p">)</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_POSTPROCESSING</span><span class="p">)</span>
                <span class="n">states</span><span class="p">[</span><span class="o">~</span><span class="n">is_sunny</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="n">SUNNY_DOWN</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DARK_DOWN</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_DONE</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stop_when_finished</span> <span class="o">&lt;=</span> <span class="n">current_step</span><span class="p">:</span>
            <span class="c1"># do the post computation hook (default, setting negative states positive)</span>
            <span class="c1"># and then exit</span>
            <span class="n">post_computation_hook</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
            <span class="k">return</span> 

        <span class="n">current_step</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># calculate trench and set the rest as preliminary estimation for the eddies</span>
        <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_PREPARATION</span><span class="p">)</span>
        <span class="n">states</span><span class="p">[</span><span class="n">is_sunny</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="n">UNSET</span><span class="p">)]</span> <span class="o">=</span> <span class="n">SUNNY_EDDIES</span>

        <span class="c1"># look only at the coordinates with state == UNSET</span>
        <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">)</span>
        <span class="n">_viability_capture_basin</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span>
                                <span class="n">target_states</span><span class="o">=</span><span class="p">[</span>
                                               <span class="n">SUNNY_EDDIES</span><span class="p">,</span> <span class="o">-</span><span class="n">SUNNY_EDDIES</span><span class="p">,</span> 
                                               <span class="n">SUNNY_ABYSS</span><span class="p">,</span> <span class="o">-</span><span class="n">SUNNY_ABYSS</span>  <span class="c1"># a tad imprecise that both negative states are in here</span>
                                               <span class="p">],</span>
                                <span class="n">reached_state</span><span class="o">=</span><span class="n">DARK_EDDIES</span><span class="p">,</span> 
                                <span class="n">bad_state</span><span class="o">=</span><span class="n">TRENCH</span><span class="p">,</span> 
                                <span class="n">work_state</span><span class="o">=</span><span class="n">UNSET</span><span class="p">,</span> 
                                <span class="n">evolutions</span><span class="o">=</span><span class="n">all_evols</span><span class="p">,</span> 
                                <span class="o">**</span><span class="n">viability_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">compute_eddies</span><span class="p">:</span>
            <span class="c1"># assume all eddies are abysses</span>
            <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_POSTPROCESSING</span><span class="p">)</span>
            <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">==</span> <span class="n">SUNNY_EDDIES</span><span class="p">)]</span> <span class="o">=</span> <span class="n">SUNNY_ABYSS</span>
            <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">==</span> <span class="n">UNSET</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DARK_ABYSS</span>
            <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">==</span> <span class="n">DARK_EDDIES</span><span class="p">)]</span> <span class="o">=</span> <span class="n">DARK_ABYSS</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># the preliminary estimations for sunny and dark eddie are set</span>
            <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">,</span> <span class="n">STATUS_EDDIES_SUNNY</span><span class="p">,</span> <span class="n">STATUS_PREPARATION</span><span class="p">)</span>
            <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">==</span> <span class="n">SUNNY_EDDIES</span><span class="p">)]</span> <span class="o">=</span> <span class="n">UNSET</span>
            <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">,</span> <span class="n">STATUS_EDDIES_SUNNY</span><span class="p">,</span> <span class="n">STATUS_COMPUTATION</span><span class="p">)</span>
            <span class="n">_viability_capture_basin</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span>
                                    <span class="n">target_states</span><span class="o">=</span><span class="p">[</span><span class="n">DARK_EDDIES</span><span class="p">,</span> <span class="o">-</span><span class="n">DARK_EDDIES</span><span class="p">],</span>
                                    <span class="n">reached_state</span><span class="o">=</span><span class="n">SUNNY_EDDIES</span><span class="p">,</span> 
                                    <span class="n">bad_state</span><span class="o">=</span><span class="n">SUNNY_ABYSS</span><span class="p">,</span> 
                                    <span class="n">work_state</span><span class="o">=</span><span class="n">UNSET</span><span class="p">,</span> 
                                    <span class="n">evolutions</span><span class="o">=</span><span class="n">all_evols</span><span class="p">,</span> 
                                    <span class="o">**</span><span class="n">viability_kwargs</span><span class="p">)</span>
            <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">,</span> <span class="n">STATUS_EDDIES_SUNNY</span><span class="p">,</span> <span class="n">STATUS_DONE</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MAX_ITERATION_EDDIES</span><span class="p">):</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">,</span> <span class="n">STATUS_EDDIES_DARK</span><span class="p">,</span> <span class="n">STATUS_PREPARATION</span><span class="p">)</span>
                <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">==</span> <span class="n">DARK_EDDIES</span><span class="p">)]</span> <span class="o">=</span> <span class="n">UNSET</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">,</span> <span class="n">STATUS_EDDIES_DARK</span><span class="p">,</span> <span class="n">STATUS_COMPUTATION</span><span class="p">)</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="n">_viability_capture_basin</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span>
                                                  <span class="n">target_states</span><span class="o">=</span><span class="p">[</span><span class="n">SUNNY_EDDIES</span><span class="p">,</span> <span class="o">-</span><span class="n">SUNNY_EDDIES</span><span class="p">],</span>
                                                  <span class="n">reached_state</span><span class="o">=</span><span class="n">DARK_EDDIES</span><span class="p">,</span> 
                                                  <span class="n">bad_state</span><span class="o">=</span><span class="n">DARK_ABYSS</span><span class="p">,</span> 
                                                  <span class="n">work_state</span><span class="o">=</span><span class="n">UNSET</span><span class="p">,</span> 
                                                  <span class="n">evolutions</span><span class="o">=</span><span class="n">all_evols</span><span class="p">,</span> 
                                                  <span class="o">**</span><span class="n">viability_kwargs</span><span class="p">)</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">,</span> <span class="n">STATUS_EDDIES_DARK</span><span class="p">,</span> <span class="n">STATUS_DONE</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">changed</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">,</span> <span class="n">STATUS_EDDIES_SUNNY</span><span class="p">,</span> <span class="n">STATUS_PREPARATION</span><span class="p">)</span>
                <span class="n">states</span><span class="p">[(</span><span class="n">states</span> <span class="o">==</span> <span class="n">SUNNY_EDDIES</span><span class="p">)]</span> <span class="o">=</span> <span class="n">UNSET</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">,</span> <span class="n">STATUS_EDDIES_SUNNY</span><span class="p">,</span> <span class="n">STATUS_COMPUTATION</span><span class="p">)</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="n">_viability_capture_basin</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span>
                                                  <span class="n">target_states</span><span class="o">=</span><span class="p">[</span><span class="n">DARK_EDDIES</span><span class="p">,</span> <span class="o">-</span><span class="n">DARK_EDDIES</span><span class="p">],</span>
                                                  <span class="n">reached_state</span><span class="o">=</span><span class="n">SUNNY_EDDIES</span><span class="p">,</span> 
                                                  <span class="n">bad_state</span><span class="o">=</span><span class="n">SUNNY_ABYSS</span><span class="p">,</span> 
                                                  <span class="n">work_state</span><span class="o">=</span><span class="n">UNSET</span><span class="p">,</span> 
                                                  <span class="n">evolutions</span><span class="o">=</span><span class="n">all_evols</span><span class="p">,</span> 
                                                  <span class="o">**</span><span class="n">viability_kwargs</span><span class="p">)</span>
                <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_COMPUTATION</span><span class="p">,</span> <span class="n">STATUS_EDDIES_SUNNY</span><span class="p">,</span> <span class="n">STATUS_DONE</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">changed</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warn</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;reached MAX_ITERATION_EDDIES = </span><span class="si">%i</span><span class="s2"> during the Eddies calculation&quot;</span><span class="o">%</span><span class="n">MAX_ITERATION_EDDIES</span><span class="p">)</span>
    <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_DONE</span><span class="p">)</span>

    <span class="n">current_step</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">current_step</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;consistency check failed, bug? (</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_step</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># there is a -2 in the assert statement because a trailing &#39;&quot;&quot;&#39; is added to &#39;TOPOLOGY_STEP_LIST&#39; in order to have &#39;&quot;&quot;&#39; as the default for &#39;stop_when_finished&#39;</span>

    <span class="c1"># computation is done,</span>
    <span class="c1"># do the post computation hook (default, setting negative states positive)</span>
    <span class="c1"># and then exit</span>
    <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_POSTPROCESSING</span><span class="p">)</span>
    <span class="n">post_computation_hook</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
    <span class="n">set_global_status</span><span class="p">(</span><span class="n">TOPOLOGY_STEP_LIST</span><span class="p">[</span><span class="n">current_step</span><span class="p">],</span> <span class="n">STATUS_DONE</span><span class="p">)</span>

    <span class="c1"># clean up</span>
    <span class="k">global</span> <span class="n">STATUS</span>
    <span class="n">STATUS</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">STATUS_PREFIX</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> </div>


</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Tim Kittel.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>